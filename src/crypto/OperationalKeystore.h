#pragma once

#include <crypto/CHIPCryptoPAL.h>
#include <lib/core/CHIPError.h>
#include <lib/core/DataModelTypes.h>
#include <lib/support/Span.h>

namespace chip {
namespace Crypto {

class OperationalKeystore
{
public:
    /**
     * @brief Initialize the OperationalKeystore, possibly communicating with OS hardware
     *        resources.
     *
     * @retval CHIP_NO_ERROR on success
     * @retval CHIP_ERROR_INCORRECT_STATE if already initialized
     * @retval other CHIP_ERROR values from implementation on failure
     */
    virtual CHIP_ERROR Init() = 0;

    /**
     * @brief Finalize the keystore, automatically reverting the pending keypair, if one exists.
     */
    virtual void Finish() = 0;

#if 0
    // ==== Controller-only API ====

    /**
     * @brief Ingest an existing externally-owned P256Keypair for the given FabricIndex.
     *
     * The `externalKeypair` must be at least as long as the lifetime of
     * OperationalKeystore::Finish() call. If one is already installed, it is
     * replaced for usage by the newer one passed-in.
     *
     * @param fabricIndex - FabricIndex for which the keypair is to be used
     * @param externalKeypair - Pointer to an existing implementation of P256Keypair * that will be used
     *                          for `SignWithOpKeypair` for that FabricIndex for this OperationalKeystore
     * @retval CHIP_NO_ERROR on success
     * @retval CHIP_ERROR_INVALID_ARGUMENT if `fabricIndex` is not a valid value
     * @retval CHIP_ERROR_INCORRECT_STATE if Init() had not been called or Finish() was already called
     * @retval CHIP_ERROR_NOT_IMPLEMENTED if `IngestKeypairForFabric` is not supported (this should be the
     *                                    case for any target that is commissionable via Matter).
     * @retval other CHIP_ERROR value on internal errors
     */
    virtual CHIP_ERROR IngestKeypairForFabric(FabricIndex fabricIndex, P256Keypair * externalKeypair) = 0;
#endif

    // ==== Commissionable-only API (although can be used by controllers) ====
TODO: need to know if NewOpKeyPair is for EXISTING fabric in CSRRequest!!!!!

    /**
     * @brief This initializes a new keypair for the given fabric and generates a CSR for it,
     *        so that it can be passed in a CSRResponse.
     *
     * The keypair is temporary and becomes usable for `SignWithOpKeypair` only after either
     * `ActivateOpKeypairForFabric` or `CommitOpKeypairForFabric is called. It is destroyed if
     * `RevertPendingKeypairs` or `Finish` is called before `CommitOpKeypairForFabric`.
     *  If a pending keypair already existed, it is replaced by this call.
     *
     *  Only one pending operational keypair is supported at a time.
     *
     * @param fabricIndex - FabricIndex for which a new keypair must be made available
     * @param certificateSigningRequest - Buffer to contain the CSR. Must be at least `kMAX_CSR_Length` large.
     *
     * @retval CHIP_NO_ERROR on success
     * @retval CHIP_ERROR_BUFFER_TOO_SMALL if `certificateSigningRequest` buffer is too small
     * @retval CHIP_ERROR_INCORRECT_STATE if Init() had not been called or Finish() was already called
     * @retval CHIP_ERROR_INVALID_FABRIC_INDEX if there is already a pending keypair for another `fabricIndex` value
     *                                         or if fabricIndex is an invalid value.
     * @retval CHIP_ERROR_NOT_IMPLEMENTED if only `IngestKeypairForFabric` is supported
     * @retval other CHIP_ERROR value on internal crypto engine errors
     */
    virtual CHIP_ERROR NewOpKeypairForFabric(FabricIndex fabricIndex, MutableByteSpan & certificateSigningRequest) = 0;

    /**
     * @brief Temporarily activates the operational keypair last generated with `NewOpKeypairForFabric`, so
     *        that `SignWithOpKeypair` starts using it.
     *
     * This is to be used by AddNOC and UpdateNOC so that a prior key generated by NewOpKeypairForFabric
     * can be used for CASE while not committing it yet to permanent storage to remain after fail-safe.
     *
     * @param fabricIndex - FabricIndex for which to activate the keypair, used for security cross-checking
     *
     * @retval CHIP_NO_ERROR on success
     * @retval CHIP_ERROR_INCORRECT_STATE if Init() had not been called or Finish() was already called
     * @retval CHIP_ERROR_INVALID_FABRIC_INDEX if there is no pending operational keypair for `fabricIndex`
     * @retval CHIP_ERROR_NOT_IMPLEMENTED if only `IngestKeypairForFabric` is supported
     * @retval other CHIP_ERROR value on internal crypto engine errors
     */
    virtual CHIP_ERROR ActivateOpKeypairForFabric(FabricIndex fabricIndex) = 0;

    /**
     * @brief Permanently commit the operational keypair last generated with `NewOpKeypairForFabric`,
     *        replacing a prior one previously committed, if any, so that `SignWithOpKeypair` for the
     *        given `FabricIndex` permanently uses the key that was pending.
     *
     * This is to be used when CommissioningComplete is successfully received
     *
     * @param fabricIndex - FabricIndex for which to commit the keypair, used for security cross-checking
     *
     * @retval CHIP_NO_ERROR on success
     * @retval CHIP_ERROR_INCORRECT_STATE if Init() had not been called or Finish() was already called
     * @retval CHIP_ERROR_INVALID_FABRIC_INDEX if there is no pending operational keypair for `fabricIndex`
     * @retval CHIP_ERROR_NOT_IMPLEMENTED if only `IngestKeypairForFabric` is supported
     * @retval other CHIP_ERROR value on internal crypto engine errors
     */
    virtual CHIP_ERROR CommitOpKeypairForFabric(FabricIndex fabricIndex) = 0;

    /**
     * @brief Permanently release the operational keypair last generated with `NewOpKeypairForFabric`,
     *        such that `SignWithOpKeypair` uses the previously committed key (if one existed).
     *
     * This is to be used when on fail-safe expiry prior to CommissioningComplete.
     *
     * This method cannot error-out and must always succeed, even on a no-op. This should
     * be safe to do given that `CommitOpKeypairForFabric` must succeed to make a new operational
     * keypair usable.
     */
    virtual void RevertPendingKeypairs() = 0;

    // ==== Primary operation required: signature
    /**
     * @brief Sign a message with a fabric's currently-active operational keypair.
     *
     * If a Keypair was successfully made temporarily active with `ActivateOpKeypairForFabric`, then
     * that is the keypair whose private key is used. Otherwise, the last committed private key
     * is used, if one exists
     *
     * @param fabricIndex - FabricIndex whose operational keypair will be used to sign the `message`
     * @param message - Message to sign with the currently active operational keypair
     * @param out_signature - Buffer to contain the signature
     *
     * @retval CHIP_NO_ERROR on success
     * @retval CHIP_ERROR_INCORRECT_STATE if Init() had not been called or Finish() was already called
     * @retval CHIP_ERROR_INVALID_FABRIC_INDEX if no active key is found for the given `fabricIndex` or if
     *                                         `fabricIndex` is invalid.
     * @retval other CHIP_ERROR value on internal crypto engine errors
     *
     */
    virtual CHIP_ERROR SignWithOpKeypair(FabricIndex fabricIndex, ByteSpan message, P256ECDSASignature & out_signature) const = 0;
};

} // namespace Crypto
} // namespace chip